// An N-dimensional field is
// written u(x) = (u_1(x),u_2(x),...,u_N(x)),
// where x = x_1,x_2,...,x_N. Here the case is N=3 and cartesian labels x,y,z.
// Data is allocated contiguous as a long one-dimensional array. 
// Thus we need to allocate Mx*My*Mz*3 of space for a function u(x) = (u_x(x),u_y(x),u_z(x)).

#include <assert.h>
#include <iostream>
#include "common.h"

template <class T>
class Field
{
private:
        //Loading sizes directly in here enables us to use .size()-method fast.
        //Note that this is the "computer" size including ghost points, not the
        //"mathematical" size.
        Int mx_; //actual sizes of the dimensions (including ghostpoints)
        Int my_;
        Int mz_;
        Int totsize_;
        Int nvar_;

        //Where space is allocated.
        T *data_;
        
public:
        Field(Int Mx, Int My, Int Mz, Int nvar); //Constructor
        ~Field(); //Destructor

        //Utilities
        inline Int totSize() const; //returns total arraysize Mx*My*Mz*nvar

        //Get/Set values by (i,j,k)-indices
        inline const T get(Int xi, Int yi, Int zi, Int vi);
        inline const void set(Int xi, Int yi, Int zi, Int vi, T val);
        
}; //end class Field


//------------ Constructors and destructor ------------

//Constructor
template <class T>
Field<T>::Field(Int Mx, Int My, Int Mz, Int nvar) :
        mx_(Mx),
        my_(My),
        mz_(Mz),
        totsize_(Mx*My*Mz*nvar),
        nvar_(nvar),
        data_((Mx*My*Mz*nvar)>0 ? new T[Mx*My*Mz*nvar] : NULL)
{
        
}

//Destructor
template <class T>
Field<T>::~Field()
{
        delete[] data_;
        data_=0;
}

//------------ Utilities ------------
template<class T>
inline Int Field<T>::totSize() const {
        return totsize_;
}

//------------ Get/Set values by (i,j,k)-indices ------------
//By inputting the (i,j,k)-indices and var index we compute the corresponding
//linear index with row-major order and return/set the value at that index.
//We assume that we always have ghosts.
template<class T>
inline const T Field<T>::get(Int xi, Int yi, Int zi, Int vi = 0)
{
        assert(xi*yi*zi*vi >= 0 && xi*yi*zi*vi < totsize_); //Safeguard against invalid input
        
        return data_[vi*(mx_*my_*mz_(zi+mz_*(yi+my_*xi))
                ];
}
              
template<class T>
inline const void Field<T>::set(Int xi, Int yi, Int zi, Int vi, T val)
{
        assert(xi*yi*zi*vi >= 0 && xi*yi*zi*vi < totsize_);
        data_[vi*(zi+mz_*(yi+my_*xi))] = val;
}
    
